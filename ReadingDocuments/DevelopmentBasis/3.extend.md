# 类，超类和子类

&emsp;&emsp;之前写了一个Employee类但是公司里肯定不止一个类型的职员，为了区分现在有一个Manage类，这个类有Employee类的所有特性和方法但是也有一些独属于自己属性和方法，现在Manage类和Employee类的关系就是"is-a"关系,"is-a"关系是继承关系中很明显的特征。</br>

## 定义子类

&emsp;&emsp;关键字extends表示继承,如何使用如下：</br>

```Java
public class Manage extends Employee{
  added methods and fields
}

Java中用extends代替了c++中的":"
```
&emsp;&emsp;关键字extends指示正在构造的新类派生于一个已经存在的类。这个已经存在的类被称为超类，基类或父类；新类则被称为子类或派生类。作为父类并不是因为他优于子类比子类拥有更多的方法或功能，恰恰相反，子类拥有比父类更多的功能。在Java规范中说子类并不能继承父类中的私有属性，因为子类不能直接访问这些字段。也就是声明为私有的类成员不会被这个类的子类继承。在设计父子类的时候经常将最基本的方法放到父类中，将特殊的方法放到子类中，这种设计目前很常用。</br>

## 覆盖方法

&emsp;&emsp;有时候父类中的方法并不能使用与子类，这个时候就需要子类对其进行方法覆盖。有时候重写方法需要调用父类中的方法，但是由于子类中也有同样的方法，这个时候就应该使用super关键字，super关键字表示调用的是父类中的方法。super经常拿来与this来对比，this有两个含义：一是指示隐式参数的引用，二是调用该类的其他构造器，super也哦有两个含义一个是调用父类的方法，二是调用父类中的构造器。super并不是一个对象的引用，只是一个只是编译器调用父类方法的关键字。</br>

## 子类构造器

&emsp;&emsp;由于子类并不能直接访问父类中的私有字段，所以需要调用一个构造器来对这些个字段进行初始化，可以利用super语法调用这个构造器。使用super调用构造器的语句必须是子类构造器的第一条语句。如果构造子类对象时没有显示地调用父类的构造器，那么超类必须有一个无参构造器，这个构造器要在子类构造器之前调用。</br>

&emsp;&emsp;虚拟机在执行的时候可以知道当前对象变量引用的是父类还是子类对象从而调用正确的方法。一个对象变量可以指示多种实际类型，这一点被称为多态。在运行时能够自动的选择适当的方法，这称为动态绑定。</br>

## 继承层次结构

&emsp;&emsp;继承并不仅限于一个层次。一个祖先类可以有多个子孙类。但是在JAVA中不支持多重继承。</br>

## 多态

&emsp;&emsp;用“is-a”规则可以判断是否应该将数据设计为继承关系，子类的每个对象也是父类的对象。is-a也可以称之为替换原则，意思是程序中所有需要父类对象的地方都可以使用自类对象进行替代。在Java中，对象变量是多态的，一个对象既可以引用父类对象，也可以引用父类的任何一个子类对象。不过不能将父类的引用赋值给子类变量。在Java中子类对象数组可以转换成父类的对象数组，且不用强制类型转换，这就意味着可能出现存储错值的情况，将父类对象存放到表面上是父类数组但其实是子类数组中，会导致方法混乱，所以在创建数组时要牢记数组类型。</br>

&emsp;&emsp;多态的概念：1.同一个行为具有不同的形式或者能力;2.同一个方法可以根据不同的对象选择不同的行为方式。总结一下就是同一事物再不同情况下所有的不同形式。</br>

&emsp;&emsp;多态存在的条件：1.必须存在继承或者实现关系；2.子类必须重写父类中的个别方法；3.父类的引用必须指向子类对象</br>

## 理解方法调用
&emsp;&emsp;例子：x.f(args),饮食参数x声明为c的一个对象。</br>

&emsp;&emsp;1.编译器查看对象的声明类型和方法名。需要注意的是有可能存在多个名字相同但参数类型不同的方法。编译器将会一一列举c类中所有名为f的方法和其父类中所有名为f而且可访问的方法。(父类的私有方法不可访问)。至此编译器已经知道所有可能要调用的候选方法</br>

&emsp;&emsp;2.接下来，编译器要确定方法调用中提供的参数类型。若果在所有名为f的方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为重载解析，如果没有找到或者发现经过类型转换后有多个方法与之匹配，编译器就会报告一个错误。至此，编译器已经知道需要调用的方法的名字和参数类型。</br>

&emsp;&emsp;3.如果是private方法，static方法，final方法或者构造器，那么编译器可以准确地知道应该调用哪个方法。这称为静态绑定。与此对应的是，如果要调用的方法依赖于隐式参数的实际类型，namebixvzaiyunxingshid使用动态绑定。</br>

&emsp;&emsp;4.程序运行并且采用动态绑定调用方法时，虚拟机必须调用与x所引用的对象的实际类型对应的哪个方法。假设x的实际类型是d，它是c类的子类。如果d类定义了方法f(String)，就会调用这个方法；否则将在d类的超类中寻找f(String)依此类推。</br>

&emsp;&emsp;动态绑定有一个非常重要的特征：无需修改代码就可以对程序进行扩展。</br>

&emsp;&emsp;在覆盖一个方法的时候，子类方法不能低于父类方法的可见性。具体来说就是父类方法是public子类必须也是public，如果省略不写，那么编译器就会报错</br>

## 阻止继承：final类和方法

&emsp;&emsp;有时候不希望某个类被定义子类，这个时候就需要使用final关键字来修饰。也可以将类中的某个特定的方法声明为final那么所有子类都不能覆盖这个方法。枚举和记录就被声明为final类型不允许被修改。</br>

## 强制类型转换

&emsp;&emsp;Java不止支持基本数据类型的强制转换，也支持对象的强制类型转换。进行类型的强制类型转换的原因是：要在暂时忘记对象的实际类型之后使用对象的全部功能。当然对象的强制类型转换只能在继承层次结构内进行，而且在转换之前应该使用instanceof进行检查。实际开发中尽量别用，容易发生一些意料之外的事情，增加开发难度。</br>

## instanceof模式匹配

&emsp;&emsp;用于检查某个对象是否是某指定类或者其子类的一个实例对象。用法如下：</br>

```Java
a instanceof class
```

## 受保护访问

&emsp;&emsp;整理一下范围修饰符的范围：1.private--仅本类可以访问，2.public--谁都可以访问(外部访问)3.protected--本包和所有子类可以访问4.不加修饰符(默认)--本包可以访问。</br>

# 2.Object：所有类和超类

&emsp;&emsp;Object类是所有类的父类。但是在写程序的时候不需要显示表示。</br>

## Object类型的变量

&emsp;&emsp;可以使用Object类型的变量引用任何类型的对象。当然Object类型的变量只能用于作为任意值的一个泛型容器，要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的强制类型转换。在Java中只有基本类型不是对象，其他的包括数组都扩展了Object类的类型。</br>

## equals方法

&emsp;&emsp;Object类中的equals方法用于检测一个对象是否等于另外一个对象。Object类中实现的equals方法将确定两个对象引用是否相同。这是一个合理的默认行为：如果两个对象相同，则这两个对象肯定就相等。</br>

## 相等测试与继承

&emsp;&emsp;Java语言规范要求equals方法具有如下性质：</br>

&emsp;&emsp;&emsp;&emsp;1.自反性：对于任何非null引用x，x.equals(x)应该返回true</br>

&emsp;&emsp;&emsp;&emsp;2.对称性：对于任何引用x和y，当且仅当x.equals(y)返回true时，y.equals(x)也返回true</br>

&emsp;&emsp;&emsp;&emsp;3.传递性：对于任何x，y，z，如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)也返回true</br>

&emsp;&emsp;&emsp;&emsp;4.一致性：如果x和y引用对象没有发生变化，则反复调用x.equals(y)的结果不变</br>

&emsp;&emsp;&emsp;&emsp;5.对于任何非null引用x，x.equals(null)应该返回false</br>

&emsp;&emsp;就对称性而言，但参数分别属于子类和父类的时候会有一些不同的结果。就现在来看有两种完全不同的情形：1.如果子类可能有自己的相等性概念，则对称性需求强制使用getClass检测2.如果由超累决定相等性概念，那么可以使用instanceof检测，这样不同字类的对象也可能相等。</br>

&emsp;&emsp;编写完美equals方法的技巧：</br>
&emsp;&emsp;&emsp;&emsp;1.将显示参数命名为otherObject，稍后需要将他强制类型转换成另一个名为other的变量。</br>

&emsp;&emsp;&emsp;&emsp;2.检测this与otherObject是否相同：if(this == otherObject) return true;这个检测是个优化，因为检查同一性要比逐个比较字段开销小。</br>

&emsp;&emsp;&emsp;&emsp;3.检测otherObject是否为null，如果为null，则返回false，这是个必要检测</br>

&emsp;&emsp;&emsp;&emsp;4.比较this与otherObject的类。如果equals的语义可以在子类中改变，那么就用getClass检测。如果所有的子类都有相同的相等性语义，则可以使用instanceof进行检测</br>

&emsp;&emsp;&emsp;&emsp;5.现在根据相等性概念的要求来比较字段。使用==来比较基本类型字段，使用Objects.equals比较对象字段。匹配返回true</br>

&emsp;&emsp;ps:对于数组类型的字段可以使用静态的Array.equals方法检查相应的数组元素是否相等，</br>

## hashCode方法

&emsp;&emsp;散列码是由对象导出的一个整形值。由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值由对象的存储地址得出。而且equals必须与散列码相容，比如x.equals(y)为true那么x.hashCode()就必须返回和y.hashCode()相同的值。</br>

## toString方法

&emsp;&emsp;Object中还有一个重要方法toString，返回一个字符串，表示这个对象的值。绝大多数toString方法都遵循这样的格式：首先是类名，随后是一对方括号括起来的字段值。实际上最好通过getClass().getName()获得类名的字符串，而不要将类名硬编码写到toString中。</br>

```Java

public String toString(){
  return getClass().getName();
}
```
&emsp;&emsp;经常使用toString来调试程序， 更常用的是log。</br>

# 3.泛型数组列表
## 声明数组列表
## 访问数组列表元素
## 类型华语原始数据数组列表的兼容性
