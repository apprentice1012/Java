# 接口

&emsp;&emsp;接口用来描述类应该做什么，而不指定他们具体应该如何做。一个类可以实现一个或多个接口。只要符合所要求的接口，就可以实现这个借口的类的对象。</br>

## 接口的概念

&emsp;&emsp;接口不是类，而是对希望符合这个接口的类的一组需求。接口中所有的方法自动都是public的，因此可以不提供public关键字。接口中绝不可以有实例字段名但是可以定义常量，在Java8之前接口中的方法都是抽象方法，现在允许有其他方法存在但是不能引用实例字段。</br>

&emsp;&emsp;为了让类实现一个接口，需要完成以下两个步骤：</br>

&emsp;&emsp;&emsp;&emsp;1.将类声明为实现给定的接口</br>

&emsp;&emsp;&emsp;&emsp;2.对接口中的所有方法提供定义</br>

&emsp;&emsp;使用接口的主要原因在于：Java语言是一种强类型语言。调用方法时，编译器要能检查这个方法确实存在。</br>

## 接口的属性

&emsp;&emsp;接口不是类。具体来说，不能使用new操作符实例化一个接口。不过尽管不能构造接口对象，但仍能声明接口变量，接口变量必须引用实现了这个接口的一个类对象:</br>

```Java
x = new Comparable(...);//ERROR
Comparable x;//OK
x = new Employee()...;//OK provided Employee implements Comparable
```

&emsp;&emsp;遇见李磊的层次结构一样，也可以扩展接口。这里允许有多条接口链，从通用性较高的接口扩展到专用性较高的接口。<br>

&emsp;&emsp;虽然接口不能包含实例字段，但是可以包含常量。</br>

&emsp;&emsp;尽管每个类只能有一个父类，但是可以实现多个接口。这就为定义类的行为提供了极大的灵活性。</br>

## 接口与抽象类

&emsp;&emsp;由于每个类只能扩展一个类，所以抽象基类表示通用属性存在严重问题。假设一个类已经扩展了一个父类就不能扩展其他类了但是有需要其他类的方法，这个时候就不能满足了。所以要引入接口的概念。(虽然其他设计语言支持多重继承，但是Java不支持因为多重继承会让代码变得更复杂或者降低效率)实际上，接口可以提供多重继承的多种好处，同时还能避免多重继承的复杂性和低效性。</br>

## 静态和私有方法

&emsp;&emsp;在Java8中，允许在街口增加静态方法。目前为止通常的做法是将静态方法放在伴随类中。</br>

&emsp;&emsp;在Java9中，接口中的方法可以是private方法，可以是静态的或者是实例的。由于用处有限，所以多用于其他方法的辅助方法。</br>

## 默认方法

&emsp;&emsp;可以为任何借口方法提供一个默认实现。必须用default修饰符标记这样一个方法。默认方法最重要的作用就是：接口演化。新增加方法，原来的类可以正常使用。</br>

## 解决默认方法冲突

&emsp;&emsp;如果在一个接口中定义了默认方法，但是在父类或者另一个接口中存在同样的方法，那么将会依照下面连个原则来解决问题：</br>

&emsp;&emsp;&emsp;&emsp;1.父类优先。如果父类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</br>

&emsp;&emsp;&emsp;&emsp;2.接口冲突。如果一个接口提供了一个默认方法，另一个接口提供了同样的方法(无论是否是默认的)，必须覆盖这个方法解决冲突。</br>

```Java

```
## 接口与回调
## Comparator接口
## 对象克隆
# lambda表达式
## 为什么引入lambda表达式
## lambda表达式的语法
## 函数式接口
## 方法引用
## 构造器引用
## 变量作用域
## 处理lambda表达式
## 在谈Comparator
# 内部类
## 使用内部类访问对象状态
## 内部类的特殊语法规则
## 内部类是否有用，必要和安全
## 局部内部类
## 由外部方法访问变量
## 匿名内部类
## 静态内部类
# 服务加载器
# 代理
## 何时使用代理
## 创建代理对象
## 代理类的特性
